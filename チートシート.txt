# minikubeのバージョン取得
minikube version

# minikubeの起動
minikube start --vm-driver=hyperkit

# 嘘！これだとnodePortとポート番号一致していても通信できない！！！！！！
# Docker上でminikubeを起動する場合はServiceでnodePortで指定するポート番号を予め開けておく必要がある。
# http://127.0.0.1:30000で通信できるようになる
minikube start --vm-driver=docker --ports=127.0.0.1:30000:30000

# minikubeの停止
minikube stop

# minikubeの削除
minikube delete

# 外部公開しているIPアドレスの取得（docker上にminikube立ち上げてるとportが空いていないので？外部から見れない。なぜか127.0.0.1からは見ることができる？）
minikube ip

# 外部公開しているサービスのurlを取得
minikube service サービス名 --url

# 外部公開しているサービスをブラウザで立ち上げる
minikube service サービス名

# minikubeの状態取得
minikube status

# addonの追加
minikube addons enable ingress

# addonのリスト取得
minikube addons list





# kubectlのバージョン取得
kubectl version

# kubectlのconfig情報
~/.kube/configに記載。書き換えることで変更することも可能。
例えばdocker-desktopとminikubeのcontextがある状態でcurrent-context（現在使用しているcontext）の指定をminikubeからdocker-desktopに変更したりできる。
# kubectlのconfig情報の一部を表示
kubectl config current-context

# kubectl構文の基本
kubectl [command] [TYPE] [NAME] [flags]
command：実行したい操作（get, create, patch, deleteなど）
TYPE：リソースタイプ（pod, node, service, deployment）
NAME：リソース名（特定のリソースに対してだけ操作を行いたい場合）
flags：オプションのフラグ（--kubeconfigなど）

# リソース一覧の表示（NAME, SHORTNAMES, APIVERSION, KIND等が表示されるので、yamlファイル作成時にすごく便利）
kubectl api-resources

# kubectlの出力フォーマット
kubectl [command] [TYPE] [NAME] -o <output_format>
output_formatには下記が入る。
json： JSON形式で出力。jqを一緒に使うと便利。
name： リソースタイプ/NAMEが出力
wide： プラスアルファの情報も一緒に出力
yaml： YAML形式で出力
jsonpath='{.items[*].metadata.name}'： jsonの中から指定されたパスの情報だけを取ってくる

# Resourceをリスト表示
kubectl get [TYPE] [NAME] [flags]
TYPE：リソースタイプ（pod, pods, po, node, nodes, service, svc）大文字小文字区別せず、単数系、複数形、短縮系が使える
よく使うオプション：
-n --namespace <namespace> （namespaceを指定しない場合にはdefaultというnamespaceが使われる） --all-namespacesで全てのnamespaceから取得できる
例：kubectl get pod -n kube-system（kube-systemというnamespace内のpodを取得）
# リソースの状態を取得（マニフェストファイルから。TYPE/NAME(pod/sample, replicaset.apps/sample)の取得も行える。）
kubectl get -f pod.yml
# リソースの状態更新を監視
kubectl get pod -w
# ノード上のPodリソース状態を取得。どのNodeで動いているか確認することができる！IPアドレスも取得可能。
kubectl get pod -o wide
# podのラベルも表示
kubectl get pod --show-labels
# podのラベルを使って絞る（Serviceで使用するselectorを指定。selectorのkeyはappだけとは限らない。runとか自由に付けられる）
kubectl get pod --selector app=<label名>
kubectl get pod -l app=<label名>
# ノード上のリソースの大部分（pod,service,deployment）の情報を取得
kubecdtl get all

# Resourceの詳細を表示
kubectl describe [TYPE] [NAME_PREFIX] [flags]
# リソースの概況を取得（エラーが発生して起動しない場合やクラッシュした場合など。Eventsにそういった情報が載っている）
kubectl describe TYPE(kindの事)/NAME
# 対象のNodeで動いている全てのPodを確認することができる（CPUやMemoryの状態、上限を確認することもできる）
kubectl describe node/<Node名>

# describe意外にデバッグ時に使用する方法
kubectl get pod <pod名> -o yaml

# リソースの作成
kubectl create -f pod.yml
# kubenetesのマニフェストファイルからリソース（Pod, ReplicaSet, Service）の作成
kubectl apply -f pod.yml
# コマンドのみでリソース作成（一部のTYPEのみ。作成できるものはkubectl create -hで確認することができる。）
kubectl create [TYPE] [NAME] [flags]
kubectl create namespace test-ns（test-nsというnamespaceの作成）
よく使うオプション
--dry-run：serverとclientを指定できる。clientのdry-runとyamlのoutputフォーマットを組み合わせてYAMLファイルのベースを作成するときに使うと便利。
kubectl create namespace test-ns --dry-run=client -o yaml > test-ns.yaml

# リソースの削除
kubectl delete -f pod.yml
# リソースの削除
kubectl delete -f pod.yml（ファイル名から削除）
kubectl delete TYPE(kindの事)/NAME（リソース名から削除）
# コマンドのみで作成したリソースの削除
kubectl delete [TYPE] [NAME] [flags]
kubectl delete namespace test-ns（test-nsというnamespaceの削除）

# kubernetesオブジェクトの管理方法（いずれか１つの方法で管理を行うこと。同じオブジェクトに対し複数の管理方法を組み合わせた場合、未定義の挙動をもたらす）
■ 命令型コマンド： クラスター内の現行オブジェクトに対し処理を行う。開発のみ使用。
  kubectl run nginx --image nginx
  kubectl create namespace test-ns
■ 命令型オブジェクト設定： kubectlコマンドに処理内容(create, replaceなど)、任意のフラグ、そして最低１つのファイル名を指定。ファイルが対象。本番でも使用。
  kubectl create/delete/replace -f nginx.yml
■ 宣言型オブジェクト設定： ユーザーはローカルに置かれている設定ファイルを操作。ユーザーはファイルに対する操作内容を指定しない（kubectlが検出）。ディレクトリが対象。本番でも使用。
  kubectl apply/diff -f configs/

# コンテナの中に入る
kubectl exec -it pod名 -sh
# mysqlのなかに入る
kubectl exec -n database -it mysql-754f74cc48-8nk4r -- mysql -uroot -ppassword
show databases;
use test_db;
show tables;
select * from users;


# コンテナから出る
exit（プロセスを削除して出る。）
ctrl + P -> ctrl + Q（プロセスを残して出る。本番環境等のデバッグ環境以外ではこちらで出る必要がある。もしくは終了しないようにloopをcommand実行させておくか。）

# リソース内のログを取得（describeで分からなかった場合に確認する感じ） コンテナが複数ある場合： -c <コンテナ名>
kubectl logs TYPE(kindの事)/NAME
# ログの更新を確認することができる
kubectl logs TYPE/NAME -f

# ローカルファイルをコンテナ内へコピー（Podで使用）
kubectl cp target_file pod名:/path/to/target_dir/

# コンテナ内のファイルをローカルへコピー（Podで使用）
kubectl cp pod名:/path/to/target_file ./target_file

# ロールアウト履歴確認（Deploymentで使用）
kubectl rollout history TYPE(kindの事)/NAME
# CHANGE CAUSEにコメントを残すにはmetadataのannotationsのkubernetes.io/change-causeにコメントを残す必要がある

# ロールバック（Deploymentで使用）（Nはrevisionの指定。デフォルト0）
kubectl rollout undo TYPE(kindの事)/NAME --to-revision=N

# Serviceのデバッグ方法１
# ポートフォワーディング。kubernetesクラスターの外からクラスター内のサービスにアクセスするため。Service名で（DockerではこれをやらないとServiceからNodePortで外部に公開していても見ることができない。これやるとhttp://localhost:8080が表示されるURLになる）
kubectl port-forward service/<Service名> 8080:<Serviceで公開しているPort>
# Serviceのデバッグ方法２
kubectl get endpoints <Service名>
# 準備のできているIP Addressと準備のできていないIP Addressを見ることができる。IPアドレスはkubectl get pod -o wideで確認することができる。そこからどのPodのIP Addressが用意できていないのか確認する。（→そこからselectorが正しいのか確認）
kubectl describe endpoints <Service名>

# DebugPodを一時的に起動（kubectl run debug --image=centos:7 -it --rm --restart=Never --sh）
kubectl run Pod名 --image=Image名 -it（標準入出力） --rm（自動削除） --restart=Never（Pod起動） -- sh
# デバッグPod起動実行後、ヘッドレスサービス経由でIPアドレスなしでPodにアクセス（http://nginx-0.sample-svc/）
curl http://Pod名.ヘッドレスサービス名





⚠︎⚠︎⚠︎⚠︎⚠︎ DockerImage作成時の注意点 ⚠︎⚠︎⚠︎⚠︎⚠︎
M1マックでIMAGEを作成する場合は下記では正常に作成できない。（例えばmongoコマンドがインストールできなかったりする）
docker build -t debug .
下記のコマンドのようにplatformの指定が必要
docker build --platform linux/x86_64 -t debug .
作成したIMAGEからcontainerを作成する際には同様に下記コマンドでは正常に作成できない。
docker run -it debug sh
platformの指定が必要
docker run --platform linux/x86_64 -it debug sh
【参考】
https://stackoverflow.com/questions/68630526/lib64-ld-linux-x86-64-so-2-no-such-file-or-directory-error


#mongodbのReplicaSetの初期化設定の仕方
mongo
use admin
db.auth("admin", "Passw0rd")
rs.initiate({
  _id: "rs0"
  members: [
    {_id: 0, host: "mongo-0.db-svc:27017"},
    {_id: 1, host: "mongo-1.db-svc:27017"},
    {_id: 2, host: "mongo-2.db-svc:27017"}
  ]
})

# 初期化進行状態の確認。どのPodがPrimaryでSecondaryなのかも分かる
rs.status()

# 初期化し直したい場合
# 全レプリカにある/data/db/配下のデータを全て削除して、リソースも削除、作成し直す
kubectl exec -it mongo-0 sh
rm -rf /data/db/*
kubectl exec -it mongo-1 sh
rm -rf /data/db/*
kubectl exec -it mongo-2 sh
rm -rf /data/db/*
kubectl delete -f weblog-db-headless.yml
kubectl delete persistentVolume名 persistentVolumeClaim名
